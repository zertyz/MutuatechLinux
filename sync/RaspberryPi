# For performance, Raspberry Pi's root filesystems should be RAID0 with all available pendrives + sdcard
# RAID0 allows (almost) simultaneous reads & writes across all involved devices, for higher throughputs.
# For the same reason, swap must also be spread across devices -- currently, the most performant is to use swap on zram devices backed by storage devices.
# A typical partitioning is like the following (1 2GiB sdcard + 2 1GiB usb sticks):
#Device         Boot   Start     End Sectors   Size Id Type
#/dev/mmcblk0p1            1   65535   65535    32M  b W95 FAT32
#/dev/mmcblk0p2        65536 1952767 1887232 921.5M 8e Linux LVM
#/dev/mmcblk0p3      1953792 3841024 1887233 921.5M 8e Linux LVM
#/dev/mmcblk0p4      3842048 3887103   45056    22M 82 Linux swap / Solaris
#/dev/sda2             77824 1965055 1887232 921.5M 8e Linux LVM
#/dev/sda4              2048   77823   75776    37M 82 Linux swap / Solaris
#/dev/sdb2             65536 1952767 1887232 921.5M 8e Linux LVM
#/dev/sdb4              2048   65535   63488    31M 82 Linux swap / Solaris

# note that the size of each RAID0 partition must be the same (here, 1887233 sectors) and that swap partitions fill up the remaining space.
# One might find useful the convention of setting the swap partitions to be the forth (#4) and data partitions to be #2 and #3 (possibly also #1 for usb sticks)

# The root RAID0 mdadm is, in our example, created with:
# mdadm --create /dev/md0 --verbose -c 32 --level=0 --raid-devices=$n /dev/mmcblk0p2 /dev/sda2 /dev/mmcblk0p3 /dev/sdb2  # where '32' is the common denominator between all low level media block sizes and '$n' is the number of devices on the array (4, in our case). Note to find the low level media block size one might find the following command usefull -- note that it will destroy all data on the device: 'dd if=/dev/zero of=/dev/sdX bs=$((32*1024)) oflag=sync count=$((1024*64)) status=progress' -- this command will write ~2GiB on the device using direct IO. Mess around with the number 32 (on the bs= parameter) to find the block size, in kilobytes, your device uses internally. The logic behind it is: solid state media can only write full blocks. If you attempt a number which is too low, say 8, each block will be written 4 times in order to fill the device with zeroes. Thus, the correct block size will be the smallest one (power of 2) which will produce the faster write throughput. Note that if one of the devices have a block size of 32k and another, say 128k, your RAID0 array should use a block size of 128k.

# mkfs.ext4 -b 4096 -E resize=$((32*(1024*1024*1024)/4096)),stride=$((32/4)),stripe-width=$(((32/4)*n)),packed_meta_blocks=1 -m 0 -O flex_bg /dev/md0
# tune2fs -L "SmallPiArray" -c 3 -e remount-ro -o journal_data_writeback,nobarrier /dev/md0
# don't forget to enable 'mdadm_udev' at initcpio and use UUID in cmdline.txt to reference the meadm rootfs -- the 'HOOKS' line on /etc/mkinitcpio.conf should be something like 'HOOKS=(base udev autodetect modconf block mdadm_udev filesystems keyboard fsck)'

# boot filesystem
mkfs.vfat -a -f 1 -h 0 -R 1 -s 8 -n "SmallPiBoot" /dev/mmcblk0p1

# packages to be added after all conflicts gets solved
git base-devel gcc clang cmake boost
gst-omx-rpi transmission-cli


# packages

# kodi
kodi-eventclients-rbp-git kodi-rbp-git kodi-tools-texturepacker-rbp-git

# GUI
xorg xf86-video-fbturbo-git lxqt

# pi graphics
gst-omx-rpi libbcm2835 omxplayer-git
fbset libcec-rpi mplayer fbida

# local compilation
base-devel clang

# C++ runtime
boost-libs

# generic userland
p7zip
rsync
mlocate
netcat lftp
ntp
screen
unrar
unzip
upower
vim
wget
wpa_supplicant
xterm
time
zip

hostnamectl set-hostname BigPi

echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
locale-gen
localectl set-locale LANG="en_US.UTF-8"

timedatectl set-timezone America/Sao_Paulo
ntpdate br.pool.ntp.org
hwclock -w

# hacks on /boot/config.txt
gpu_mem=16
#cma_lwm=16
#cma_hwm=32
#cma_offline_start=16

# rPi2
arm_freq=1100
gpu_freq=500
sdram_freq=500
over_voltage=6
initial_turbo=60

# maximum turbo for rPi1
arm_freq=1000
gpu_freq=500
sdram_freq=600
over_voltage=6
over_voltage_sdram=6
initial_turbo=60

# create a new service -- contents of /etc/systemd/system/localstartup.service
[Unit]
Description=Local Startup Script
 
[Service]
ExecStart=/root/bin/localstartup
 
[Install]
WantedBy=multi-user.target

# proceed by placing in /root/bin/localstartup
	#! /bin/bash
	# remember we are without systemd, so this script must manually do things like setting up the network, assembling mdadm arrays and mounting points

	swapoff -a
	modprobe zram num_devices=5
	((z=0))
	for d in /dev/mmcblk0p3 /dev/sda1 /dev/sdb1 /dev/sdc1 /dev/sdd1; do
		echo $d   >/sys/block/zram${z}/backing_dev
		echo lz4  >/sys/devices/virtual/block/zram${z}/comp_algorithm
		echo 32m  >/sys/devices/virtual/block/zram${z}/mem_limit
		echo 63m  >/sys/devices/virtual/block/zram${z}/disksize
		mkswap /dev/zram${z}
		swapon -p 15 /dev/zram${z}
		((z++))
	done
	swapon -s

	# network
	sleep 3
	ifconfig eth0 up
	dhcpcd -p eth0
	ifconfig -a
	sleep 5
	pkill dhcpcd

	ntpdate br.pool.ntp.org

	pkill agetty
	pkill -f 'user'         # kills systemd --user process
	pkill dbus-daemon

	# mounting points
	mount /boot
	mdadm --assemble --scan
	mount /data

# fstab
/dev/mmcblk0p2                                  /               ext4    defaults,noatime,discard,barrier=0,commit=600   0       1

UUID=def560f7-3932-41e7-ba6c-42094c903141       /data           ext4    defaults,noauto,noatime,barrier=0,commit=600   0       2

/dev/mmcblk0p1                                  /boot           vfat    defaults,noauto        0       2

//192.168.1.1/disk1_1                           /mnt/Router32Gb cifs    async,file_mode=0777,dir_mode=0777,username=SalaShare,password=SalaShare,vers=1.0       0       0


# systemd services enabling / disabling -- WARNING: first edit your fstab and put all your non-root partitions as noauto, because they won't be able to mount at boot anymore and will render the machine unbootable if you fail to do this
systemctl enable localstartup.service
systemctl disable haveged
for service in lvm2-lvmetad lvm2-lvmetad.socket getty@tty1.service lvm2-lvmpolld.service lvm2-lvmpolld.socket lvm2-monitor.service lvm2-pvscan@.service serial-getty@ttyAMA0.service tmp.mount systemd-timesyncd.service systemd-logind.service systemd-journald.service systemd-udevd.service systemd-networkd systemd-resolved dbus.service; do systemctl mask $service; done

# /etc/sysctl.d/99-mutuatechTweaks.conf
vm.swappiness = 10
vm.vfs_cache_pressure = 10
vm.dirty_ratio = 80
vm.dirty_background_ratio = 80
vm.dirty_writeback_centisecs = 60000
vm.dirty_expire_centisecs    = 60000

kernel.sysrq=1


# systemd tweaks (/etc/systemd)
coredump.conf: Storage=none
journald.conf: Storage=none

# root over ssh (only with keys):
/etc/ssh/sshd_config: PermitRootLogin prohibit-password
